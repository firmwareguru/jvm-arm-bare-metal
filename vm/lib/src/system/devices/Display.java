/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package system.devices;

import java.io.InputStream;
import java.io.OutputStream;
import system.Device;

/**
 *
 * @author Evan Ross
 */
public class Display extends Device
{
    
//*****************************************************************************
//
// From rit128x96x4.c:
//
// A 5x7 font (in a 6x8 cell, where the sixth column is omitted from this
// table) for displaying text on the OLED display.  The data is organized as
// bytes from the left column to the right column, with each byte containing
// the top row in the LSB and the bottom row in the MSB.
//
// Note:  This is the same font data that is used in the EK-LM3S811
// osram96x16x1 driver.  The single bit-per-pixel is expaned in the StringDraw
// function to the appropriate four bit-per-pixel gray scale format.
//
//*****************************************************************************    
    private static final byte[][] font =
    {
    { 0x00, 0x00, 0x00, 0x00, 0x00 }, // " "
    { 0x00, 0x00, 0x4f, 0x00, 0x00 }, // !
    { 0x00, 0x07, 0x00, 0x07, 0x00 }, // "
    { 0x14, 0x7f, 0x14, 0x7f, 0x14 }, // #
    { 0x24, 0x2a, 0x7f, 0x2a, 0x12 }, // $
    { 0x23, 0x13, 0x08, 0x64, 0x62 }, // %
    { 0x36, 0x49, 0x55, 0x22, 0x50 }, // &
    { 0x00, 0x05, 0x03, 0x00, 0x00 }, // '
    { 0x00, 0x1c, 0x22, 0x41, 0x00 }, // (
    { 0x00, 0x41, 0x22, 0x1c, 0x00 }, // )
    { 0x14, 0x08, 0x3e, 0x08, 0x14 }, // *
    { 0x08, 0x08, 0x3e, 0x08, 0x08 }, // +
    { 0x00, 0x50, 0x30, 0x00, 0x00 }, // ,
    { 0x08, 0x08, 0x08, 0x08, 0x08 }, // -
    { 0x00, 0x60, 0x60, 0x00, 0x00 }, // .
    { 0x20, 0x10, 0x08, 0x04, 0x02 }, // /
    { 0x3e, 0x51, 0x49, 0x45, 0x3e }, // 0
    { 0x00, 0x42, 0x7f, 0x40, 0x00 }, // 1
    { 0x42, 0x61, 0x51, 0x49, 0x46 }, // 2
    { 0x21, 0x41, 0x45, 0x4b, 0x31 }, // 3
    { 0x18, 0x14, 0x12, 0x7f, 0x10 }, // 4
    { 0x27, 0x45, 0x45, 0x45, 0x39 }, // 5
    { 0x3c, 0x4a, 0x49, 0x49, 0x30 }, // 6
    { 0x01, 0x71, 0x09, 0x05, 0x03 }, // 7
    { 0x36, 0x49, 0x49, 0x49, 0x36 }, // 8
    { 0x06, 0x49, 0x49, 0x29, 0x1e }, // 9
    { 0x00, 0x36, 0x36, 0x00, 0x00 }, // :
    { 0x00, 0x56, 0x36, 0x00, 0x00 }, // ;
    { 0x08, 0x14, 0x22, 0x41, 0x00 }, // <
    { 0x14, 0x14, 0x14, 0x14, 0x14 }, // =
    { 0x00, 0x41, 0x22, 0x14, 0x08 }, // >
    { 0x02, 0x01, 0x51, 0x09, 0x06 }, // ?
    { 0x32, 0x49, 0x79, 0x41, 0x3e }, // @
    { 0x7e, 0x11, 0x11, 0x11, 0x7e }, // A
    { 0x7f, 0x49, 0x49, 0x49, 0x36 }, // B
    { 0x3e, 0x41, 0x41, 0x41, 0x22 }, // C
    { 0x7f, 0x41, 0x41, 0x22, 0x1c }, // D
    { 0x7f, 0x49, 0x49, 0x49, 0x41 }, // E
    { 0x7f, 0x09, 0x09, 0x09, 0x01 }, // F
    { 0x3e, 0x41, 0x49, 0x49, 0x7a }, // G
    { 0x7f, 0x08, 0x08, 0x08, 0x7f }, // H
    { 0x00, 0x41, 0x7f, 0x41, 0x00 }, // I
    { 0x20, 0x40, 0x41, 0x3f, 0x01 }, // J
    { 0x7f, 0x08, 0x14, 0x22, 0x41 }, // K
    { 0x7f, 0x40, 0x40, 0x40, 0x40 }, // L
    { 0x7f, 0x02, 0x0c, 0x02, 0x7f }, // M
    { 0x7f, 0x04, 0x08, 0x10, 0x7f }, // N
    { 0x3e, 0x41, 0x41, 0x41, 0x3e }, // O
    { 0x7f, 0x09, 0x09, 0x09, 0x06 }, // P
    { 0x3e, 0x41, 0x51, 0x21, 0x5e }, // Q
    { 0x7f, 0x09, 0x19, 0x29, 0x46 }, // R
    { 0x46, 0x49, 0x49, 0x49, 0x31 }, // S
    { 0x01, 0x01, 0x7f, 0x01, 0x01 }, // T
    { 0x3f, 0x40, 0x40, 0x40, 0x3f }, // U
    { 0x1f, 0x20, 0x40, 0x20, 0x1f }, // V
    { 0x3f, 0x40, 0x38, 0x40, 0x3f }, // W
    { 0x63, 0x14, 0x08, 0x14, 0x63 }, // X
    { 0x07, 0x08, 0x70, 0x08, 0x07 }, // Y
    { 0x61, 0x51, 0x49, 0x45, 0x43 }, // Z
    { 0x00, 0x7f, 0x41, 0x41, 0x00 }, // [
    { 0x02, 0x04, 0x08, 0x10, 0x20 }, // "\"
    { 0x00, 0x41, 0x41, 0x7f, 0x00 }, // ]
    { 0x04, 0x02, 0x01, 0x02, 0x04 }, // ^
    { 0x40, 0x40, 0x40, 0x40, 0x40 }, // _
    { 0x00, 0x01, 0x02, 0x04, 0x00 }, // `
    { 0x20, 0x54, 0x54, 0x54, 0x78 }, // a
    { 0x7f, 0x48, 0x44, 0x44, 0x38 }, // b
    { 0x38, 0x44, 0x44, 0x44, 0x20 }, // c
    { 0x38, 0x44, 0x44, 0x48, 0x7f }, // d
    { 0x38, 0x54, 0x54, 0x54, 0x18 }, // e
    { 0x08, 0x7e, 0x09, 0x01, 0x02 }, // f
    { 0x0c, 0x52, 0x52, 0x52, 0x3e }, // g
    { 0x7f, 0x08, 0x04, 0x04, 0x78 }, // h
    { 0x00, 0x44, 0x7d, 0x40, 0x00 }, // i
    { 0x20, 0x40, 0x44, 0x3d, 0x00 }, // j
    { 0x7f, 0x10, 0x28, 0x44, 0x00 }, // k
    { 0x00, 0x41, 0x7f, 0x40, 0x00 }, // l
    { 0x7c, 0x04, 0x18, 0x04, 0x78 }, // m
    { 0x7c, 0x08, 0x04, 0x04, 0x78 }, // n
    { 0x38, 0x44, 0x44, 0x44, 0x38 }, // o
    { 0x7c, 0x14, 0x14, 0x14, 0x08 }, // p
    { 0x08, 0x14, 0x14, 0x18, 0x7c }, // q
    { 0x7c, 0x08, 0x04, 0x04, 0x08 }, // r
    { 0x48, 0x54, 0x54, 0x54, 0x20 }, // s
    { 0x04, 0x3f, 0x44, 0x40, 0x20 }, // t
    { 0x3c, 0x40, 0x40, 0x20, 0x7c }, // u
    { 0x1c, 0x20, 0x40, 0x20, 0x1c }, // v
    { 0x3c, 0x40, 0x30, 0x40, 0x3c }, // w
    { 0x44, 0x28, 0x10, 0x28, 0x44 }, // x
    { 0x0c, 0x50, 0x50, 0x50, 0x3c }, // y
    { 0x44, 0x64, 0x54, 0x4c, 0x44 }, // z
    { 0x00, 0x08, 0x36, 0x41, 0x00 }, // {
    { 0x00, 0x00, 0x7f, 0x00, 0x00 }, // |
    { 0x00, 0x41, 0x36, 0x08, 0x00 }, // }
    { 0x02, 0x01, 0x02, 0x04, 0x02 }, // ~
    { 0x00, 0x00, 0x00, 0x00, 0x00 }
};
    
    private static final byte[] verticalInc = 
    {
        (byte)0xA0, 
        (byte)0x56 
    };
    
    private static final byte[] horizontalInc = 
    {
        (byte)0xA0,
        (byte)0x52
    };
    
    
    // Buffer for storing commands and data for the display
    byte[] ssiBuffer = null;
    
    SSI ssi = null;
    GPIO gpio = null;
    
    public Display(SSI ssi, GPIO gpio)
    {
        super(0,0,0);
        this.ssi = ssi;
        this.gpio = gpio;
        
        ssiBuffer = new byte[8];
    }

    /**
     * Construct a non-functional Display.  Do not use any write methods.
     * Used for access to display parameters.
     */
    public Display()
    {
        super(0,0,0);
        this.ssi = null;
        this.gpio = null;

        ssiBuffer = null;
    }

    
    
    @Override
    public void write(int b)
    {
        write((byte)b, 0, 0);
    }
    
    public void write(byte b, int x, int y)
    {
        // brightness
        int level = 15;
        
        //
        // Setup a window starting at the specified column and row, ending
        // at the right edge of the display and 8 rows down (single character row).
        //
        ssiBuffer[0] = 0x15;
        ssiBuffer[1] = (byte)(x / 2);
        ssiBuffer[2] = 63;
        writeCommand(ssiBuffer, 3);
        ssiBuffer[0] = 0x75;
        ssiBuffer[1] = (byte)y;
        ssiBuffer[2] = (byte)(y + 7);
        writeCommand(ssiBuffer, 3);
        
        writeCommand(verticalInc, verticalInc.length);
        
        int glyphIndex = b;
        if (glyphIndex < ' ') {
            glyphIndex = ' ';
        } else {
            glyphIndex -= ' ';
        }

        for (int idx1 = 0; idx1 < 6; idx1 += 2)
        {
            //
            // Convert two columns of 1-bit font data into a single data
            // byte column of 4-bit font data.
            //
            for (int idx2 = 0; idx2 < 8; idx2++)
            {
                ssiBuffer[idx2] = 0;
                if ((font[glyphIndex][idx1] & (1 << idx2)) != 0)
                {
                    ssiBuffer[idx2] = (byte)((level << 4) & 0xf0);
                }
                if ((idx1 < 4) &&
                   (font[glyphIndex][idx1 + 1] & (1 << idx2)) != 0)
                {
                    ssiBuffer[idx2] |= (level << 0) & 0x0f;
                }
            }

            //
            // Send this byte column to the display.
            //
            writeData(ssiBuffer, 8);
            x += 2;
        }
    }
    
    private void writeCommand(byte[] buffer, int numBytes)
    {
        // Clear the command/control bit
        gpio.pinWrite(GPIO.GPIO_PORTA_BASE, GPIO.GPIO_PIN_6, 0);
        
        for (int i = 0; i < buffer.length; i++)
            ssi.write(buffer[i]);
    }
    
    private void writeData(byte[] buffer, int numBytes)
    {
        gpio.pinWrite(GPIO.GPIO_PORTA_BASE, GPIO.GPIO_PIN_6, GPIO.GPIO_PIN_6);
        for (int i = 0; i < buffer.length; i++)
            ssi.write(buffer[i]);
    }
    
    public int getFontHeight()
    {
        return 8;
    }
    
    public int getFontWidth()
    {
        return 6;
    }
    
    public int getDisplayHeight()
    {
        return 96; // rows
    }
    
    public int getDisplayWidth()
    {
        return 128; // columns
    }
    
    @Override
    public int read()
    {
        return 0;
    }
    
    @Override
    public OutputStream getOutputStream() {
        return new OLEDOutputStream(this);
    }
    
    @Override
    public InputStream getInputStream() {
        return null;
    }    
            
}
